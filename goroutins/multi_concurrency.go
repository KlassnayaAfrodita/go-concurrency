package main

func main() {
	//? map. работать не будет. ошибка конкурентности записи и чтения, тк обращаемся к одной переменной

	// m := make(map[int]int)
	// go func() {
	// 	for i := 0; i < 100000; i++ {
	// 		m[0] = i
	// 	}
	// }()

	// go func() {
	// 	for i := 0; i < 100000; i++ {
	// 		if m[i] < 0 { //? имитация чтения из мапы
	// 			//? some action
	// 		}
	// 	}
	// }()

	//? со стрингом так же, потому что запись и чтение не атомарные операции (либо выполнены, либо нет)

	// var count int

	// for i := 0; i < 1e5; i++ {
	// 	go func() {
	// 		count++
	// 	}()
	// }
	// time.Sleep(time.Second / 2)
	// fmt.Println(count)
	//? выводит меньше, чем надо, потому что инкримация инта не атомарная операция

	//! безопасный конкурентный доступ
	//! ОЧЕНЬ ВАЖНО
	// arr := [1e6]int{}
	// fmt.Println(len(arr), arr[:5], arr[len(arr)-5:])
	// for i := 0; i < len(arr); i++ {
	// 	go func(i int) {
	// 		arr[i] = i * i //? каждая горутина работает только со своим элементом массива с индексом i. никакие две горутины не борятся за один индекс
	// 	}(i)
	// }

	// time.Sleep(time.Second / 2)
	// fmt.Println(len(arr), arr[:5], arr[len(arr)-5:])
}
